# 风险及免责提示：该策略由聚宽用户分享，仅供学习交流使用。
# 原文一般包含策略说明，如有疑问建议到原文和作者交流讨论。
# 克隆自聚宽文章：https://www.joinquant.com/view/community/detail/19302
# 标题：个股择时有效？因子选股+双均线择时效果初步尝试
# 回测请选择 python 2 .

import numpy as np
import pandas as pd
import time 
from datetime import date
from jqdata import *
import statsmodels.api as sm




'''
================================================================================
总体回测前
================================================================================
'''
#总体回测前要做的事情
def initialize(context):
    set_params()        #1 设置策参数
    set_variables()     #2 设置中间变量
    set_backtest()      #3 设置回测条件
    # 定时运行函数（reference_security为运行时间的参考标的；传入的标的只做种类区分，因此传入'000300.XSHG'或'510300.XSHG'是一样的）
    # 开盘前运行，按月运行，每个月初获取holding_list
    run_monthly(before_market_open, monthday = 1, time = 'before_open', reference_security='000906.XSHG')
    # 开盘时运行，交易函数，按日运行，每天调仓
    run_daily(market_open, time = 'open', reference_security = '000906.XSHG')
    # 收盘后运行
    run_daily(after_market_close, time='after_close', reference_security='000906.XSHG')

    
#设置策参数
def set_params():
    g.yb = 63               # 定义计算波动因子观测期长度
    g.shift = 63            # g.shift天未停牌的股票
    g.beta = 252            # 定义计算beta的观测天数
    g.percent = 0.1         # 持仓比例
    g.index = '000906.XSHG' # 定义基准中证800
    g.rf = 0.04             # 定义无风险收益率为4%
    g.short_d = 5           # 定义短期均线的计算区间2,5,10
    g.long_d = 60           # 定义长期均线的计算区间20,40,60
    '''
    8个大类因子，分别为波动、反转、市值、股息、成长、价值、质量、系统风险
    全文仅仅在此处进行修改，要测试哪个因子，就把g.factor改为该因子
    '''
    # 设定要检测的因子
    g.factor = 'value'
    # 按照factors的值排序，True为值小的在前面，False为值大的在前面
    g.factor_sort = {'market_cap':True,'value':True,'beta':False}
    
    g.factor_sort = {'market_cap':True,'value':True,'beta':False}


#设置中间变量
def set_variables():
    g.feasible_stocks = []  # 当前可交易股票池
    g.holding_list = []     # 定义全局holding_list
    g.buy_list = []         # 择时信号为买入的股票列表
    g.sell_list = []        # 择时信号为卖出的股票列表


#设置回测条件
def set_backtest():
    set_benchmark('000906.XSHG')                    # 以中证800为基准
    set_option('use_real_price', True)              # 用真实价格交易
    log.info('初始函数开始运行且全局只运行一次')    # 输出内容到日志 log.info()
    log.set_level('order', 'error')                 # 设置报错等级，过滤掉order系列API产生的比error级别低的log


'''
================================================================================
每天开盘前
================================================================================
'''
# 每天开盘前要做的事情
def before_market_open(context):
    # 输出运行时间
    log.info('函数运行时间(before_market_open)：'+str(context.current_dt.time()))
    # 设置手续费与滑点
    set_slip_fee(context) 
    # 设置可行股票池：获得当前开盘的中证800股票池并剔除当前或者计算样本期间停牌的股票
    g.feasible_stocks = set_feasible_stocks(get_index_stocks('000906.XSHG'),g.shift,context)
    # 获取g.holding_list
    g.holding_list = get_holding_list(context)
    

# 根据不同的时间段设置滑点与手续费
def set_slip_fee(context):
    # 将滑点设置为0
    set_slippage(FixedSlippage(0)) 
    # 根据不同的时间段设置手续费
    dt=context.current_dt

    if dt>datetime.datetime(2013,1, 1):
        set_commission(PerTrade(buy_cost=0.0003, sell_cost=0.0013, min_cost=5)) 
        
    elif dt>datetime.datetime(2011,1, 1):
        set_commission(PerTrade(buy_cost=0.001, sell_cost=0.002, min_cost=5))
            
    elif dt>datetime.datetime(2009,1, 1):
        set_commission(PerTrade(buy_cost=0.002, sell_cost=0.003, min_cost=5))
                
    else:
        set_commission(PerTrade(buy_cost=0.003, sell_cost=0.004, min_cost=5))


# 设置可行股票池：
# 过滤掉当日停牌的股票,且筛选出前days天未停牌股票
# 输入：stock_list-list类型,样本天数days-int类型，context（见API）
# 输出：可行股票池-list类型
def set_feasible_stocks(stock_list,days,context):
    # 得到是否停牌信息的dataframe，停牌的1，未停牌得0
    suspened_info_df = get_price(list(stock_list), start_date=context.current_dt, end_date=context.current_dt, frequency='daily', fields='paused')['paused'].T
    # 过滤停牌股票 返回dataframe
    unsuspened_index = suspened_info_df.iloc[:,0]<1
    # 得到当日未停牌股票的代码list:
    unsuspened_stocks = list(suspened_info_df[unsuspened_index].index)
    # 进一步，筛选出前days天未曾停牌的股票list:
    feasible_stocks=[]
    current_data=get_current_data()
    for stock in unsuspened_stocks:
        if sum(attribute_history(stock, days, unit='1d', fields=('paused'), skip_paused=False))[0]==0:
            feasible_stocks.append(stock)
            
    return feasible_stocks


# 获取holding_list
def get_holding_list(context):

    # 获取市值因子数据，该df的index为code
    df_marketcap = get_df_marketcap(g.feasible_stocks,context)

    # 获取价值因子数据，该df的index为code
    df_value = get_df_value(g.feasible_stocks,context)

    # 获取系统风险β数据
    df_beta = get_df_beta(g.feasible_stocks,context)
    
    df_factors = df_value
    
    # 各个因子值合并
    # df_factors = pd.concat([df_marketcap,df_value,df_beta],axis = 1)
    
    # 各个因子值等权相加
    # df_factors['factors'] = df_factors['wave']*0 + df_factors['momentum']*0 + df_factors['market_cap']*0 + df_factors['gx_factor']*0 + df_factors['growth']*0 + df_factors['value']*0 + df_factors['z_quality']*0 + df_factors['beta']*1
    
    # 打印df_factors
    #log.info(df_factors.sort(g.factor,ascending = g.factor_sort[g.factor]))
    # 按照factors排序，True为值小的在前面，False为值大的在前面
    stocks = list(df_factors.sort(g.factor,ascending = g.factor_sort[g.factor]).index)
    # 获取前10%支股票为holding_list
    holding_list = stocks[0:int(len(stocks)*g.percent)]
    

    return holding_list


# 获取市值因子数据
def get_df_marketcap(stocks_list,context):
    # 获取总市值数据
    q = query(valuation.code,valuation.market_cap).filter(valuation.code.in_(stocks_list))
    df_marketcap = get_fundamentals(q, date = context.previous_date)
    # index列改为code列
    df_marketcap.index = df_marketcap['code']
    # 删除code列
    del df_marketcap['code']
    # z值处理
    df_marketcap = (df_marketcap - df_marketcap.mean())/df_marketcap.std()
    
    return df_marketcap


# 获取价值因子数据
def get_df_value(stocks_list,context):
    # 获取pb pe ps数据
    q = query(valuation.pb_ratio,valuation.pe_ratio,valuation.ps_ratio,valuation.code).filter(valuation.code.in_(stocks_list))
    
    factor_data = get_fundamentals(q, date = context.previous_date)
    factor_data = get_fundamentals(q, date = context.previous_date)
    
    # z值处理
    factor_data.index = factor_data['code']
    del factor_data['code']
    factor_data = (factor_data - factor_data.mean())/factor_data.std()
    # 计算价值因子
    df_value = pd.DataFrame((factor_data['pb_ratio']+factor_data['pe_ratio']+factor_data['ps_ratio'])/3)
    df_value.columns = ['value']
    
    return df_value


# 获取系统风险beta数据
def get_df_beta(stocks_list,context):
    # 获取股票收益率
    price = get_price(stocks_list,end_date = context.previous_date,count = 1+g.beta,fields = ['close'])['close']
    ri = price/price.shift(1) - 1
    ri_rf = ri - g.rf
    # 获取中证800收益率
    price_index = get_price(g.index,end_date = context.previous_date,count = 1+g.beta,fields = ['close'])
    rm = price_index/price_index.shift(1) - 1
    rm_rf = rm - g.rf
    rm_rf.columns = [g.index]
    # 定义两个list存储结果
    coef_list = []
    code_list = []
    # 对每支股票进行回归，得到回归系数
    for i in ri_rf.columns.tolist():
        # 将个股超额收益率与市场风险溢价合并
        result = pd.concat([rm_rf,ri_rf[i]],axis = 1)
        # 对列重命名，便于ols回归
        result.columns = ['rm_rf','ri_rf']
        # 去重
        result = result.dropna()
        # result有数据才回归，否则跳过
        if len(result) != 0:
            # 训练模型
            model = sm.formula.ols('rm_rf ~ ri_rf', data = result).fit()
            # 打印参数表
            # log.info(model.summary())
            # 获取系数项
            coef = model.params[1]
            # 将系数项存入一个list中
            coef_list.append(coef)
            # 将股票代码存入另一个list
            code_list.append(i)
        else:
            continue
    # 将code与系数项存入一个df
    df_beta = pd.DataFrame({'code':code_list,'beta':coef_list})
    # index列改为code
    df_beta.index = df_beta['code']
    # 删除无用数据
    del df_beta['code']
    
    return df_beta


# 计算下跌波动率，传入一个收益率df，返回一个Series
def std_ud(df,ud='d'):
    # flag标明是上还是下
    if ud=='u':
        flag = (df>df.mean())
    if ud=='d':
        flag = (df<df.mean())
        
    # 方差
    square_sum = (((df-df.mean())*flag)**2).sum()
    
    return (square_sum/(len(df)-1))**0.5
    
    
'''
================================================================================
每天交易时
================================================================================
'''
# 每天开盘时要做的事
def market_open(context):
    # 输出运行时间
    log.info('函数运行时间(market_open)：'+str(context.current_dt.time()))
    # 每天计算择时信号
    get_signal(context,g.holding_list)
    # 调仓
    rebalance(context,g.holding_list)
    # 重置买卖信号
    g.buy_list = []
    g.sell_list = []

    
# 计算择时信号，key为股票代码，value为1或-1
def get_signal(context,holding_list):
    # 对每支股票进行2（短均线）-20（长均线）择时
    for i in holding_list:
        # 2日均线crossover20日均线
        price2 = get_price(i,end_date = context.previous_date,count = 1+g.short_d,fields = ['close'])['close']
        MA2 = price2[-g.short_d:].mean()
        MA2_pre = price2[-1-g.short_d:-1].mean()
        price20 = get_price(i,end_date = context.previous_date,count = 1+g.long_d,fields = ['close'])['close']
        MA20 = price20[-g.long_d:].mean()
        MA20_pre = price20[-1-g.long_d:-1].mean()
        # 如果短期均线大于长期均线（不需要crossover，仅大于即可）
        if MA2 > MA20:
            # 买入信号
            g.buy_list.append(i)
        '''
        # 如果2日均线crossover20日均线
        if MA2 > MA20 and MA2_pre < MA20_pre:
            # 买入信号
            g.buy_list.append(i)
        '''
    # 判断当前持仓的是否满足择时的卖出条件
    if len(context.portfolio.positions.keys()) != 0:
        for j in context.portfolio.positions.keys():
            # 2日均线，20日均线
            price2 = get_price(j,end_date = context.previous_date,count = 1+g.short_d,fields = ['close'])['close']
            MA2 = price2[-g.short_d:].mean()
            MA2_pre = price2[-1-g.short_d:-1].mean()
            price20 = get_price(j,end_date = context.previous_date,count = 1+g.long_d,fields = ['close'])['close']
            MA20 = price20[-g.long_d:].mean()
            MA20_pre = price20[-1-g.long_d:-1].mean()
            # 如果短期均线小于长期均线（不需要crossunder，仅小于即可）
            if MA2 < MA20 and context.portfolio.positions[j].closeable_amount > 0:
                # 卖出信号
                g.sell_list.append(j)
            '''
            # 2日均线crossunder20日均线
            if MA2 < MA20 and MA2_pre > MA20_pre and context.portfolio.positions[j].closeable_amount > 0:
                # 卖出信号
                g.sell_list.append(j)
            '''
    log.info('buy_list',g.buy_list)
    log.info('sell_list',g.sell_list)


# 依本策略的买入信号，得到应该买的股票列表
# 借用买入信号结果，不需额外输入
# 输入：context，holding_list（见API）
def rebalance(context, holding_list):
    # 每只股票购买金额
    every_stock = context.portfolio.portfolio_value/len(holding_list)
    
    # 空仓只有买入操作
    if len(list(context.portfolio.positions.keys())) == 0:
        for stock_to_buy in g.buy_list:
            order_target_value(stock_to_buy, every_stock)
    else :
        # 不是空仓先卖出持有但是不在购买名单中的股票
        for stock_to_sell in list(context.portfolio.positions.keys()):
            # 如果不在holding_list，卖出
            if stock_to_sell not in holding_list:
                order_target_value(stock_to_sell, 0)
            # 如果在择时的sell_list里，卖出
            if stock_to_sell in g.sell_list:
                order_target_value(stock_to_sell, 0)
        # 因order函数调整为顺序调整，为防止先行调仓股票由于后行调仓股票占金额过大不能一次调整到位，这里运行两次以解决这个问题
        for stock_to_buy in g.buy_list:
            order_target_value(stock_to_buy, every_stock)
        for stock_to_buy in g.buy_list:
            order_target_value(stock_to_buy, every_stock)
    print('hold_stocks:',context.portfolio.positions.keys())
    
            
'''
================================================================================
每天收盘后
================================================================================
'''
#每天收盘后要做的事情
def after_market_close(context):
    log.info(str('函数运行时间(after_trading_end):'+str(context.current_dt.time())))
    log.info('一天结束')
    log.info('##############################################################')


