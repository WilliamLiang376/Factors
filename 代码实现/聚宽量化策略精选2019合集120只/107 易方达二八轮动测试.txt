# 风险及免责提示：该策略由聚宽用户分享，仅供学习交流使用。
# 原文一般包含策略说明，如有疑问建议到原文和作者交流讨论。
# 克隆自聚宽文章：https://www.joinquant.com/post/22555
# 标题：易方达二八轮动测试
# 作者：子鹿

# 导入函数库
import jqdata
import time
import datetime

'''
================================================================================
总体回测前
================================================================================
'''
#1
#设置策略参数
def set_params():
    g.N = 11            #N日涨幅
    g.rise_threshold = 0
    g.signal_time = "15:00" #产生信号时间
    g.ratio = 0.8

#总体回测前做的初始化工作
def initialize(context):
    set_option("avoid_future_data", True)
    set_params()        #1设置策参数
    set_backtest()      #2设置回测条件
    
    #基金池: 上证50，创业板，国债指数/货币基金
    g.fund_list = ['000016.XSHG', '000016.XSHG',\
                '399006.XSHE', '399006.XSHE',\
    #g.fund_list = ['000016.XSHG', '510050.XSHG',\
    #            '399006.XSHE', '159915.XSHE',\
    #            '511880.XSHG', '511880.XSHG']
                '000012.XSHG', '000012.XSHG']
    
    run_monthly(monthly, 1, g.signal_time)

#2
#设置回测条件
def set_backtest():
    set_benchmark('000300.XSHG')
    set_option('use_real_price',True) # 用真实价格交易
    log.set_level('order','error')    # 设置报错等级
    
    # 基金类交易手续费是：买入时佣金万分之1.5，卖出时佣金万分之1.5（免印花税）, 每笔交易佣金最低扣5块钱
    set_order_cost(OrderCost(open_tax=0, close_tax=0, \
                             open_commission=0.00015, close_commission=0.00015,\
                             close_today_commission=0, min_commission=5), type='fund')
    set_order_cost(OrderCost(open_tax=0, close_tax=0, \
                             open_commission=0, close_commission=0,\
                             close_today_commission=0, min_commission=0), type='mmf')
 
    #设置回测的滑点
    #set_slippage(FixedSlippage(0.02),type='stock')
    #set_slippage(FixedSlippage(0.002),type='fund')
    set_slippage(FixedSlippage(0),type='stock')
    set_slippage(FixedSlippage(0),type='fund')   

def monthly(context):
    #产生信号并交易
    signal = yfdebld_signal(context, g.fund_list, g.N, g.rise_threshold)
    log.info("signal=%s", signal)
    trade(context, signal, g.fund_list, g.ratio)
    trade_bond(context, g.fund_list, 1) #余钱全部买债券
    return    

def trade(context, signal, security_round_list, ratio):
    security_round_num = int(len(security_round_list)/2)    #轮动组数
    total_value = context.portfolio.total_value
    log.info("current total value: %s", total_value)
    
    # 卖出股票操作
    for i in range(security_round_num):
        if i != (signal-1):
            stk = security_round_list[i*2+1]
            if stk in context.portfolio.positions.keys():
                if i == (security_round_num -1):    #债券最少保留20%仓位
                    target_value = (1-ratio)*context.portfolio.total_value
                else:
                    target_value = 0
                order_target_value(stk, target_value, None)
                log.info("sell stk: %s to value: %s", stk, target_value)

    if signal == 3:
        return
    
    # 买入操作
    stk = security_round_list[(signal-1)*2+1]
    target_value = context.portfolio.total_value*g.ratio
    order_value(stk, target_value, None)
    log.info("buy stk: %s to target_value：%s", stk, target_value)
    return 
    
def trade_bond(context, security_round_list, ratio):    
    #余钱买债券
    security_round_num = int(len(security_round_list)/2)    #轮动组数
    stk = security_round_list[security_round_num*2-1]
    cash = context.portfolio.available_cash*ratio
    order_value(stk, cash, None)
    log.info("buy bond: %s, avail_cash：%s", stk, cash)
      
    return


#产生程序信号，返回signal
def yfdebld_signal(context, fund_list, N, rise_threshold):
    price_rise = [0,0]
    security_round_num = int(len(fund_list)/2)    #轮动组数
    
    #债券不参与计算信号标的
    for i in range(security_round_num - 1):
        stk = fund_list[i*2]
        his_data = attribute_history(stk, N, '1d', ['close'], skip_paused=True)
        price_rise[i] = his_data['close'][-1]/his_data['close'][-N] - 1     #N日涨幅   
        log.info("fund%s, price_rise=%s, yesterday=%s, prev_N = %s", i, price_rise[i], his_data['close'][-1], his_data['close'][-N])
    
    diff_price_rise = price_rise[0] - price_rise[1]
    if diff_price_rise > rise_threshold and price_rise[0] > 0:
        signal = 1
    elif diff_price_rise < -rise_threshold and price_rise[1] > 0:
        signal = 2
    else:
        signal = 3
        
    return signal