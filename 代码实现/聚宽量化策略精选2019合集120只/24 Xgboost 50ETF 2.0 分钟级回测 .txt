# 风险及免责提示：该策略由聚宽用户分享，仅供学习交流使用。
# 原文一般包含策略说明，如有疑问建议到原文和作者交流讨论。
# 克隆自聚宽文章：https://www.joinquant.com/view/community/detail/23958
# 标题：Xgboost 50ETF 2.0 分钟级回测
# 回测使用 分钟  ，需要导入附近文件.

# 附件地址 https://file.joinquant.com/e199f0c752ccc12c8d330a5f8c7cd1c4/model%2020191109.rar?_upd=model%2020191109.rar

# 导入函数库
from jqdata import *
from pandas import Series, DataFrame
import pandas as pd
import numpy as np
import scipy as sp
import statsmodels.tsa.stattools as sts
import matplotlib.pyplot as plt
import statsmodels.api as sm
import talib
import datetime
import pickle
from sklearn.model_selection import train_test_split
import xgboost as xgb
from sklearn import metrics
from six import BytesIO

# 初始化函数，设定基准等等
def initialize(context):

    # 在context中保存全局变量
    context.etf ="510050.XSHG"
    # 实时打印日志
    #logger.info("RunInfo: {}".format(context.run_info))
    run_daily(trade, '9:50',reference_security='000300.XSHG')
    # 过滤掉order系列API产生的比error级别低的log
    # log.set_level('order', 'error')

    ### 股票相关设定 ###
    # 股票类每笔交易时的手续费是：买入时佣金万分之三，卖出时佣金万分之三加千分之一印花税, 每笔交易佣金最低扣5块钱
    set_order_cost(OrderCost(close_tax=0.001, open_commission=0.00025, close_commission=0.00025, min_commission=5), type='stock')

    ## 运行函数（reference_security为运行时间的参考标的；传入的标的只做种类区分，因此传入'000300.XSHG'或'510300.XSHG'是一样的）
      # 开盘前运行
    #run_daily(before_market_open, time='before_open', reference_security='000300.XSHG')
      # 开盘时运行
    #run_daily(market_open, time='open', reference_security='000300.XSHG')
      # 收盘后运行
    #run_daily(after_market_close, time='after_close', reference_security='000300.XSHG')



def trade(context):
    X_Matrix=create_fea(context)
    print('model loaded')
    col = pickle.load(BytesIO(read_file("col_50etf_20191109.dat")))
    print('col loaded')
    dvalid = xgb.DMatrix(X_Matrix[col].tail(1))
    model = pickle.load(BytesIO(read_file("model_50etf_20191109.dat")))
    yvalid_list=[]
    for m in model:
        yvalid_list.append(m.predict(dvalid))
    yvalid=np.array([i for i in yvalid_list]).mean(axis=0)
    print('Probility: %.4f'%yvalid[0])

    cash = context.portfolio.cash
    
    if yvalid[0]>0.002:
        order_value(context.etf, cash)
    elif yvalid[0]<-0.002:
        order_target_value(context.etf, 0)


# after_trading函数会在每天交易结束后被调用，当天只会被调用一次
def after_trading(context):
    pass

def get_price(stock):
    close=attribute_history(stock, 400, '1d', 'close')['close']
    high=attribute_history(stock, 400, '1d', 'high')['high']
    low=attribute_history(stock, 400, '1d', 'low')['low']
    open=attribute_history(stock, 400, '1d', 'open')['open']
    volume=attribute_history(stock, 400, '1d', 'volume')['volume']
    return open,close,high,volume,low
    
def devfea(df,high,low,close,open,volume):
    df['AD']=talib.AD(high,low,close,volume)
    df['CCI']=talib.CCI(high,low,close)
    df['macd'], df['macdsignal'], df['macdhist'] = talib.MACD(close, fastperiod=12, slowperiod=26, signalperiod=9)
    df['ATR'] = talib.ATR(high, low, close, timeperiod=14)
    df['ADOSC']=talib.ADOSC(high,low,close,volume)
    df['ADX']=talib.ADX(high,low,close)
    df['BBANDS_upper'],df['BBANDS_mid'],df['BBANDS_lower']=talib.BBANDS(close)
    df['RSI']=talib.RSI(close)
    df['MA5']=talib.MA(close,5)
    df['MA10']=talib.MA(close,10)
    df['MA20']=talib.MA(close,20)
    df['OBV']=talib.OBV(close,volume)
    df['SAR']=talib.SAR(high, low)
    df['lgvol']=np.log(volume)
    df['upshadow']=np.abs(high-((open+close)+(np.abs(open-close)))/2)
    df['downshadow']=np.abs(low-((open+close)-(np.abs(open-close)))/2)
    return df

def devfea_roll(df,cols,ndays):
    fea=df[cols].rolling(ndays).agg(['mean','max','min','std','var','median'])
    fea.columns=["_".join(col) for col in fea.columns]
    fea.columns=fea.columns+'_rl_'+str(ndays)+'D'
    res=pd.merge(df,fea,left_index=True,right_index=True,how='inner')
    return res

def devfea_diff(df,cols,ndays):
    fea=df[cols].diff(ndays)
    fea.columns=fea.columns+'_diff_'+str(ndays)+'D'
    res=pd.merge(df,fea,left_index=True,right_index=True,how='inner')
    return res

def devfea_diff2(df,cols):
    fea=df[cols].diff(1).diff(1)
    fea.columns=fea.columns+'_diff2'
    res=pd.merge(df,fea,left_index=True,right_index=True,how='inner')
    return res

def devfea_lag(df,cols,ndays):
    fea=df[cols].shift(ndays)
    fea.columns=fea.columns+'_lag_'+str(ndays)+'D'
    res=pd.merge(df,fea,left_index=True,right_index=True,how='inner')
    return res

def ts_rank(x):
    return pd.Series(x).rank().tail(1)


def ts_rankeq10(x):
    res=(x==10)*1
    return res.sum()
    
def create_fea(context):
    open,close,high,volume,low=get_price(context.etf)
    price=pd.DataFrame({'close':close,'open':open,'high':high,'low':low,'volume':volume})
    cols=price.pipe(devfea,high,low,close,open,volume).columns
    result=(price.pipe(devfea,high,low,close,open,volume)
            .pipe(devfea_roll,cols,5)
            .pipe(devfea_roll,cols,10)
            .pipe(devfea_roll,cols,20)
            .pipe(devfea_roll,cols,30)
            .pipe(devfea_roll,cols,60)
            .pipe(devfea_diff,cols,1)
            .pipe(devfea_diff,cols,5)
            .pipe(devfea_diff,cols,10)
            .pipe(devfea_diff,cols,20)
            .pipe(devfea_diff,cols,30)
            .pipe(devfea_diff,cols,60)
            .pipe(devfea_lag,cols,1)
            .pipe(devfea_lag,cols,2)
            .pipe(devfea_lag,cols,3)
            .pipe(devfea_lag,cols,5)
            .pipe(devfea_diff2,cols)
       )
    result['long_MA5_flag']=(result['close']>result['MA5'])*1
    result['long_MA10_flag']=(result['close']>result['MA10'])*1
    result['long_MA20_flag']=(result['close']>result['MA20'])*1
    result['long_MA5_MA10']=(result['MA5']>result['MA10'])*1
    result['long_MA5_MA20']=(result['MA5']>result['MA20'])*1
    #alpha001 量价协方差，量价背离#
    result['aphla001']=result['close'].rolling(10).corr(result['volume'])
    #Alpha002 开盘缺口
    result['alpha002']=result['open']/result['close']
    #Alpha003 异常交易量
    result['alpha003']=-1*result['volume']/talib.MA(volume,20)
    #Alpha004 量幅背离
    result['alpha004']=(result['high']/result['close']).rolling(10).corr(result['volume'])
    #Alpha005 近10日价格排序值
    result['alpha005']=result['close'].rolling(10,min_periods=10).apply(ts_rank)
    #Alpha006 近10日价格排序值中10的个数
    result['alpha006']=result['alpha005'].rolling(10,min_periods=10).apply(ts_rankeq10)
    #Alpha007 最高价是近10日最高
    result['alpha007']=(result['high']==result['high_max_rl_10D'])*1
    #Alpha008 最高价是近20日最高
    result['alpha008']=(result['high']==result['high_max_rl_20D'])*1
    #Alpha009 最高价是近10日最高
    result['alpha009']=(result['low']==result['low_min_rl_10D'])*1
    #Alpha010 最高价是近20日最高
    result['alpha010']=(result['low']==result['low_min_rl_20D'])*1
    return result