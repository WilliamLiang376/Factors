# 风险及免责提示：该策略由聚宽用户分享，仅供学习交流使用。
# 原文一般包含策略说明，如有疑问建议到原文和作者交流讨论。
# 克隆自聚宽文章：https://www.joinquant.com/post/17144
# 标题：年化42%的市值选股与阶梯调仓策略
# 作者：lsydmn

# 导入函数库
from jqdata import *

# 初始化函数，设定基准等等
def initialize(context):
    g.stocknum = 20         # 设定持股数量
    g.buylist = []          # 设定买入list
    # 设定沪深300作为基准
    set_benchmark('000300.XSHG')
    set_option("avoid_future_data", True)
    # 开启动态复权模式(真实价格)
    set_option('use_real_price', True)
    # 输出内容到日志 log.info()
    log.info('初始函数开始运行且全局只运行一次')
    # 过滤掉order系列API产生的比error级别低的log
    log.set_level('order', 'error')

    ### 股票相关设定 ###
    # 股票类每笔交易时的手续费是：买入时佣金万分之三，卖出时佣金万分之三加千分之一印花税, 每笔交易佣金最低扣5块钱
    set_order_cost(OrderCost(close_tax=0.001, open_commission=0.0003, close_commission=0.0003, min_commission=5), type='stock')

    ## 运行函数（reference_security为运行时间的参考标的；传入的标的只做种类区分，因此传入'000300.XSHG'或'510300.XSHG'是一样的）
      # 开盘前运行
    run_daily(before_market_open, time='09:00', reference_security='000300.XSHG')
      # 开盘时运行
    run_daily(market_open, time='09:30', reference_security='000300.XSHG')
      # 收盘后运行
    run_daily(after_market_close, time='15:30', reference_security='000300.XSHG')
    
    
## 开盘前运行函数
def before_market_open(context):
    # 输出运行时间
    log.info(str('函数运行时间（before_market_open）:'+str(context.current_dt.time())))
    # 获取上证指数和深证综指的成份股
    scu=get_index_stocks('000001.XSHG')+get_index_stocks('399106.XSHE')
    # 获取市值最小的
    q=query(valuation.code,valuation.market_cap).filter(valuation.code.in_(scu)).order_by(valuation.market_cap.asc()).limit(g.stocknum)
    df=get_fundamentals(q,date = context.previous_date)
    print(df)
    stocklist=list(df['code'])
    # 生成买入列表
    g.buylist = stocklist
    
    
## 开盘时运行函数
def market_open(context):
    # 输出运行时间
    log.info(str('函数运行时间（market_open）:'+str(context.current_dt.time())))
    # 调仓
    rebalance(context,g.buylist)


# 调仓rebalance函数
def rebalance(context,holding_list):
    # 每只股票购买金额
    every_stock = context.portfolio.portfolio_value/len(holding_list)
    # 空仓就全部买入，等额资金
    if len(list(context.portfolio.positions.keys())) == 0:
        for stock_to_buy in holding_list:
            order_target_value(stock_to_buy, every_stock)
    # 如果不是空仓先卖出持有但是不在购买名单中的股票
    else:
        for stock_to_sell in context.portfolio.positions.keys():
            if stock_to_sell not in holding_list:
                order_target_value(stock_to_sell, 0)
        # 为holding_list里的每支股票分配等额资金
        for i in holding_list:
            order_target_value(i, every_stock)
        for i in holding_list:
            order_target_value(i, every_stock)
    # 对于当前持仓的，择时，改变持仓比例
    for stk in context.portfolio.positions.keys():
        cost=context.portfolio.positions[stk].price
        close_data = attribute_history(stk, 10, '1d', ['close'])
        close_data2 = attribute_history(stk, 15, '1d', ['close'])
        close_data3 = attribute_history(stk, 20, '1d', ['close'])
        MA10 = close_data['close'].mean()
        MA15 = close_data2['close'].mean()
        MA20 = close_data3['close'].mean()
        price = close_data['close'][-1]
        ret=price/cost-1
        if ret>0.05:
            # 卖一半
            order_value(stk,-every_stock*0.5)
        elif ret>0.1:
            # 再卖30%
            order_value(stk,-every_stock*0.3)
        elif ret>0.15:
            # 再卖20%
            order_value(stk,-every_stock*0.2)
        if MA10>price:
            # 增持20%
            order_value(stk,every_stock*0.2)
        elif MA15>price:
            # 再增持30%
            order_value(stk,every_stock*0.3)
        elif MA20>price:
            # 再增持50%
            order_value(stk,every_stock*0.5)

          
## 收盘后运行函数
def after_market_close(context):
    log.info(str('函数运行时间(after_market_close):'+str(context.current_dt.time())))
    log.info('##############################################################')


