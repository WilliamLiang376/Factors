# 风险及免责提示：该策略由聚宽用户分享，仅供学习交流使用。
# 原文一般包含策略说明，如有疑问建议到原文和作者交流讨论。
# 克隆自聚宽文章：https://www.joinquant.com/post/21262
# 标题：海龟交易体系-多资产版
# 作者：四季
# 回测请选择 分钟 ，资金需要 100万 。

# 克隆自聚宽文章：https://www.joinquant.com/post/17113
# 标题：海龟交易体系（股票版）
# 作者：BAFE
'''
作者：掘金战士（BAFE）
'''
# 导入函数库
from jqdata import *
import numpy

def initialize(context):
    set_option("avoid_future_data", True)
    set_params()        #1设置策参数
    set_variables()     #2设置中间变量
    set_backtest()      #3设置回测条件
    run_daily(daily, time='every_bar')
#1
#设置策略参数
def set_params():
    g.security = '600519.XSHG'   # 贵州茅台
    g.security = '000300.XSHG'   # 沪深300
    g.security  = '000016.XSHG'  # 中证500
    g.security = '399333.XSHE'   #  中小板
    g.security=['000300.XSHG','600519.XSHG']
    #g.security = ['601088.XSHG','000423.XSHE','600900.XSHG','600886.XSHG','000848.XSHE','000651.XSHE','000895.XSHE']+g.security
    #set_benchmark(g.security[0])
    # 系统入市的trailing date
    g.short_in_date = 20
    # 系统 exiting market trailing date
    g.short_out_date = 10
    # 系统2 exiting market trailing date
    # g.dollars_per_share是标的股票每波动一个最小单位，1手股票的总价格变化量。
    # 在国内最小变化量是0.01元，所以就是0.01×100=1
    g.dollars_per_share = 1
    # 可承受的最大损失率
    g.loss = 0.1
    # 若超过最大损失率，则调整率为：
    # 计算N值的天数
    g.number_days = 20
    # 最大允许单元
    g.unit_limit = 4
    # 系统1所配金额占总金额比例

#2
#4 根据不同的时间段设置滑点与手续费
def set_slip_fee(context):
    # 将滑点设置为0
    set_slippage(FixedSlippage(0)) 
    # 根据不同的时间段设置手续费
    dt=context.current_dt
#设置中间变量
def set_variables():
    # 初始单元
    g.unit = 1000
    # 存储N值
    #g.N = []
    g.N={}
    # 系统1的突破价格
    #g.break_price = 0
    g.break_price={}
    # 系统2的突破价格
    #g.sys = 0
    g.sys={}
    #存储唐奇安通道上轨
    #g.high=[]
    g.high={}
    #用来存储唐奇安通道下轨
    #g.low=[]
    g.low={}
    for code in g.security:
        g.sys[code]=0
        g.high[code]=[]
        g.low[code]=[]
        g.N[code]=[]
        g.break_price[code]=0
#3
#设置回测条件
def set_backtest():
    # 作为判断策略好坏和一系列风险值计算的基准
    set_option('use_real_price',True) #用真实价格交易
    log.set_level('order','error') # 设置报错等级

'''
================================================================================
每天开盘前
================================================================================
'''
#每天开盘前要做的事情
def before_trading_start(context):
    set_slip_fee(context) #设置交易费率
    for code in g.security:
        calculate_N(code)#计算N
        tqatds(code)#计算唐奇安通道上轨
        tqatdx(code)#计算唐奇安通道下轨
    #设置费率
    dt=context.current_dt
    if dt>datetime.datetime(2013,1, 1):
        set_commission(PerTrade(buy_cost=0.0003, sell_cost=0.0013, min_cost=5)) 
        
    elif dt>datetime.datetime(2011,1, 1):
        set_commission(PerTrade(buy_cost=0.001, sell_cost=0.002, min_cost=5))
            
    elif dt>datetime.datetime(2009,1, 1):
        set_commission(PerTrade(buy_cost=0.002, sell_cost=0.003, min_cost=5))
                
    else:
        set_commission(PerTrade(buy_cost=0.003, sell_cost=0.004, min_cost=5))
    
'''
================================================================================
每天交易时
================================================================================
'''
# 按分钟回测
def daily(context):
    #获取当前账户的价值和资金
    value=context.portfolio.portfolio_value
    cash=context.portfolio.cash
    value=value/len(g.security)     # 每个资产上平分资金
    cash=cash/len(g.security)
    cash1=context.portfolio.available_cash/len(g.security)
    for code in g.security:
        haigui_buy_sell(context,code,value,cash1)
def haigui_buy_sell(context,code,value,cash):
    #获取当前分钟的价格
    price=attribute_history(code, 1, '1m', 'close')
    current_price=price['close'][-1]
    Dollar_Volatility=g.N[code][-1]*1
    g.unit=value*0.01/Dollar_Volatility#当前波动率下，最大单次损失1%的购买量
    if g.sys[code]==0:
        market_in(context,current_price,g.short_in_date,code,cash)#开仓买入
    else:
        stop_loss(current_price,code)#止损
        market_add(context,current_price,g.short_in_date,code,cash)#加仓
        market_out(current_price, g.short_out_date,code)#出局
            
 #唐奇安通道上轨
def tqatds(code):
    price=attribute_history(code,20,'1d',('high','low','close'))
    g.high[code].append(max(price['high']))
    return g.high
#唐奇安通道下轨    
def tqatdx(code):
    price=attribute_history(code,20,'1d',('high','low','close'))
    g.low[code].append(min(price['low']))
    return g.low
#计算N    
def calculate_N(code):
    if len(g.N[code])==0:
        price=attribute_history(code,21,'1d',('high','low','close'))
        st1=[]
        for i in range(1,21):
            hl=price['high'][i]-price['low'][i]
            hc=price['high'][i]-price['close'][i-1]
            cl=price['close'][i-1]-price['low'][i]
            True_Range=max(hl,hc,cl)
            st1.append(True_Range)
        current_N=round(np.mean(np.array(st1)),3)
        g.N[code].append(current_N)
    else:
        price = attribute_history(code, 2, '1d',('high','low','close'))
        hl = price['high'][-1]-price['low'][-1]
        hc = price['high'][-1]-price['close'][-2]
        cl = price['close'][-2]-price['low'][-1]
         # Calculate the True Range
        True_Range = max(hl, hc, cl)
        # 计算前g.number_days（大于20）天的True_Range平均值，即当前N的值：
        current_N = round((True_Range + (g.number_days-1)*(g.N[code])[-1])/g.number_days,3)
        (g.N[code]).append(current_N)

#开仓买入
def market_in(context,current_price,in_date,code,cash):
    price=attribute_history(code,in_date,'1d', 'close')
    # 当前价格突破唐奇安通道上轨
    if current_price > g.high[code][-1]:
        #cash=context.portfolio.available_cash
        #计算当前可买量
        num_of_shares=cash/current_price
        if num_of_shares>=g.unit and g.sys[code]<int(g.unit_limit*g.unit):
            log.info('SYS买入%s：%2f.份',code, g.unit)
            order(code,int(g.unit))
            g.sys[code]+=int(g.unit)
            g.break_price[code]=current_price
 
 #加仓                   
def market_add(context,current_price,in_date,code,cash):
   #当前价格大于上次买入价格的0.5个N
    if current_price>=g.break_price[code]+0.5*g.N[code][-1]:
        #cash=context.portfolio.available_cash
        num_of_shares=cash/current_price
        if num_of_shares>=g.unit and g.sys[code]<int(g.unit_limit*g.unit):
            log.info('g.sys加仓{}:{}'.format(code,current_price))
            order(code,int(g.unit))
            g.sys[code]+=int(g.unit)
            g.break_price[code]=current_price
#出局
def market_out(current_price,out_date,code):
    price=attribute_history(code,out_date,'1d',('close','low'))
    #当前价格低于唐奇安通道下轨
    if current_price<g.low[code][-1] and g.sys[code]>0:
        log.info('SYS离场-%s',code)
        order_target(code, 0)
        g.sys[code]=0
#止损                        
def stop_loss(current_price,code):
    #价格距离最后买入价格回调2个单位的波动
    if current_price<g.break_price[code]-2*g.N[code][-1]:
        log,info('SYS止损')
        order_target(code, 0)
        g.sys[code]=0
