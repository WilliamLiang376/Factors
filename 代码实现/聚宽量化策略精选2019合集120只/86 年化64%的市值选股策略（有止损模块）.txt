# 风险及免责提示：该策略由聚宽用户分享，仅供学习交流使用。

# 导入函数库
from jqdata import *

# 初始化函数，设定基准等等
def initialize(context):
    g.stocknum = 20         # 设定持股数量
    g.buylist = []          # 设定买入list
    g.shift = 63            # 设定停牌观测期
    g.short_d = 10           # 双均线短线
    g.long_d = 50           # 双均线长线
    # 设定沪深300作为基准
    set_benchmark('000300.XSHG')
    # 开启动态复权模式(真实价格)
    set_option('use_real_price', True)
    # 输出内容到日志 log.info()
    log.info('初始函数开始运行且全局只运行一次')
    # 过滤掉order系列API产生的比error级别低的log
    log.set_level('order', 'error')

    ## 运行函数（reference_security为运行时间的参考标的；传入的标的只做种类区分，因此传入'000300.XSHG'或'510300.XSHG'是一样的）
      # 开盘前运行
    run_daily(before_market_open, time='09:00', reference_security='000300.XSHG')
      # 开盘时运行
    run_daily(market_open, time='09:30', reference_security='000300.XSHG')
      # 收盘后运行
    run_daily(after_market_close, time='15:30', reference_security='000300.XSHG')
    
    
## 开盘前运行函数
def before_market_open(context):
    # 输出运行时间
    log.info(str('函数运行时间（before_market_open）:'+str(context.current_dt.time())))
    # 获取上证指数和深证综指的成份股
    scu=get_index_stocks('000001.XSHG')+get_index_stocks('399106.XSHE')
    # 设置可行股票池：剔除当前或者计算样本期间停牌的股票
    scu = set_feasible_stocks(scu,g.shift,context)
    # 获取市值最小的
    q=query(valuation.code,valuation.market_cap).filter(valuation.code.in_(scu)).order_by(valuation.market_cap.asc()).limit(g.stocknum)
    df=get_fundamentals(q,date = context.previous_date)
    print(df)
    stocklist=list(df['code'])
    # 生成买入列表
    g.buylist = stocklist


# 根据不同的时间段设置滑点与手续费
def set_slip_fee(context):
    # 将滑点设置为0
    set_slippage(FixedSlippage(0)) 
    # 根据不同的时间段设置手续费
    dt=context.current_dt

    if dt>datetime.datetime(2013,1, 1):
        set_commission(PerTrade(buy_cost=0.0003, sell_cost=0.0013, min_cost=5)) 
        
    elif dt>datetime.datetime(2011,1, 1):
        set_commission(PerTrade(buy_cost=0.001, sell_cost=0.002, min_cost=5))
            
    elif dt>datetime.datetime(2009,1, 1):
        set_commission(PerTrade(buy_cost=0.002, sell_cost=0.003, min_cost=5))
                
    else:
        set_commission(PerTrade(buy_cost=0.003, sell_cost=0.004, min_cost=5))


# 设置可行股票池：
# 过滤掉当日停牌的股票,且筛选出前days天未停牌股票
# 输入：stock_list-list类型,样本天数days-int类型，context（见API）
# 输出：可行股票池-list类型
def set_feasible_stocks(stock_list,days,context):
    # 得到是否停牌信息的dataframe，停牌的1，未停牌得0
    suspened_info_df = get_price(list(stock_list), start_date=context.current_dt, end_date=context.current_dt, frequency='daily', fields='paused')['paused'].T
    # 过滤停牌股票 返回dataframe
    unsuspened_index = suspened_info_df.iloc[:,0]<1
    # 得到当日未停牌股票的代码list:
    unsuspened_stocks = list(suspened_info_df[unsuspened_index].index)
    # 进一步，筛选出前days天未曾停牌的股票list:
    feasible_stocks=[]
    current_data=get_current_data()
    for stock in unsuspened_stocks:
        if sum(attribute_history(stock, days, unit='1d', fields=('paused'), skip_paused=False))[0]==0:
            feasible_stocks.append(stock)
            
    return feasible_stocks

    
## 开盘时运行函数
def market_open(context):
    # 输出运行时间
    log.info(str('函数运行时间（market_open）:'+str(context.current_dt.time())))
    # 调仓
    rebalance(context,g.buylist)
    # 止损
    zhisun(context)

# 调仓rebalance函数
def rebalance(context,holding_list):
    # 每只股票购买金额
    every_stock = context.portfolio.portfolio_value/len(holding_list)
    # 空仓就全部买入，等额资金
    if len(list(context.portfolio.positions.keys())) == 0:
        for stock_to_buy in holding_list:
            order_target_value(stock_to_buy, every_stock)
    # 如果不是空仓先卖出持有但是不在购买名单中的股票
    else:
        for stock_to_sell in context.portfolio.positions.keys():
            if stock_to_sell not in holding_list:
                order_target_value(stock_to_sell, 0)
        # 为holding_list里的每支股票分配等额资金
        for i in holding_list:
            order_target_value(i, every_stock)
        for i in holding_list:
            order_target_value(i, every_stock)
    # 执行阶梯调仓策略
    #jieti(context)
    

# 止损模块
def zhisun(context):
    # 当前持仓股票如果有crossunder的，平掉
    for i in context.portfolio.positions.keys():
        # 2日均线，20日均线
        price2 = get_price(i,end_date = context.previous_date,count = 1+g.short_d,fields = ['close'])['close']
        MA2 = price2[-g.short_d:].mean()
        MA2_pre = price2[-1-g.short_d:-1].mean()
        price20 = get_price(i,end_date = context.previous_date,count = 1+g.long_d,fields = ['close'])['close']
        MA20 = price20[-g.long_d:].mean()
        MA20_pre = price20[-1-g.long_d:-1].mean()
        # 2日均线crossunder20日均线
        if MA2 < MA20 and MA2_pre > MA20_pre and context.portfolio.positions[i].closeable_amount > 0:
            # 卖出
            order_target_value(i, 0)



# 阶梯调仓策略
def jieti(context):
    # 对于当前持仓的，择时，改变持仓比例
    for stk in context.portfolio.positions.keys():
        cost=context.portfolio.positions[stk].price
        close_data = attribute_history(stk, 10, '1d', ['close'])
        close_data2 = attribute_history(stk, 15, '1d', ['close'])
        close_data3 = attribute_history(stk, 20, '1d', ['close'])
        MA10 = close_data['close'].mean()
        MA15 = close_data2['close'].mean()
        MA20 = close_data3['close'].mean()
        price = close_data['close'][-1]
        ret=price/cost-1
        if ret>0.05:
            # 卖一半
            order_value(stk,-every_stock*0.5)
        elif ret>0.1:
            # 再卖30%
            order_value(stk,-every_stock*0.3)
        elif ret>0.15:
            # 再卖20%
            order_value(stk,-every_stock*0.2)
        if MA10>price:
            # 增持20%
            order_value(stk,every_stock*0.2)
        elif MA15>price:
            # 再增持30%
            order_value(stk,every_stock*0.3)
        elif MA20>price:
            # 再增持50%
            order_value(stk,every_stock*0.5)

          
## 收盘后运行函数
def after_market_close(context):
    log.info(str('函数运行时间(after_market_close):'+str(context.current_dt.time())))
    log.info('##############################################################')

